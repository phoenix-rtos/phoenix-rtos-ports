# This patch:
# - adds opt-in healthchecking mechanism to the main loop and exposes MT-safe
#		API for heartbeat request/response
# - renames priority[] to lpriority[] due to name clash with priority() from
#   sys/threads.h included by pthread.h
diff -ruN a/src/lparser.c b/src/lparser.c
--- a/src/lparser.c	2025-07-15 14:44:32.483563970 +0200
+++ b/src/lparser.c	2025-07-15 14:44:01.989917605 +0200
@@ -1026,7 +1026,7 @@
 static const struct {
   lu_byte left;  /* left priority for each binary operator */
   lu_byte right; /* right priority */
-} priority[] = {  /* ORDER OPR */
+} lpriority[] = {  /* ORDER OPR */
    {10, 10}, {10, 10},           /* '+' '-' */
    {11, 11}, {11, 11},           /* '*' '%' */
    {14, 13},                  /* '^' (right associative) */
@@ -1060,14 +1060,14 @@
   else simpleexp(ls, v);
   /* expand while operators have priorities higher than 'limit' */
   op = getbinopr(ls->t.token);
-  while (op != OPR_NOBINOPR && priority[op].left > limit) {
+  while (op != OPR_NOBINOPR && lpriority[op].left > limit) {
     expdesc v2;
     BinOpr nextop;
     int line = ls->linenumber;
     luaX_next(ls);
     luaK_infix(ls->fs, op, v);
     /* read sub-expression with higher priority */
-    nextop = subexpr(ls, &v2, priority[op].right);
+    nextop = subexpr(ls, &v2, lpriority[op].right);
     luaK_posfix(ls->fs, op, v, &v2, line);
     op = nextop;
   }
--- a/src/lstate.c	2025-07-15 14:44:32.483563970 +0200
+++ b/src/lstate.c	2025-07-15 14:44:01.989917605 +0200
@@ -334,14 +334,70 @@
     close_state(L);
     L = NULL;
   }
+#ifdef LUA_HEALTHCHECK_EVAL
+  if (pthread_mutex_init(&L->mutex, NULL) < 0) {
+    close_state(L);
+    L = NULL;
+  } else {
+    L->react = 0;
+    L->alive = 0;
+  }
+#endif
   return L;
 }
 
 
 LUA_API void lua_close (lua_State *L) {
   L = G(L)->mainthread;  /* only the main thread can be closed */
+#ifdef LUA_HEALTHCHECK_EVAL
+  pthread_mutex_destroy(&L->mutex);
+#endif
   lua_lock(L);
   close_state(L);
 }
 
 
+#ifdef LUA_HEALTHCHECK_EVAL
+LUA_API int lua_sendheartbeatrequest (lua_State *L) {
+  int res;
+  if (L == NULL) {
+    return -1;
+  }
+  L = G(L)->mainthread;  /* only the main thread can send heartbeat */
+  pthread_mutex_lock(&L->mutex);
+  if (L->react != 0) {
+    /* thread didn't respond to the previous heartbeat */
+    res = -1;
+  } else {
+    L->alive = 0;
+    L->react = 1;
+    res = 0;
+  }
+  pthread_mutex_unlock(&L->mutex);
+  return res;
+}
+
+
+LUA_API int lua_getheartbeatresponse (lua_State *L) {
+  int res;
+  if (L == NULL) {
+    return -1;
+  }
+  L = G(L)->mainthread;  /* only the main thread can get heartbeat response */
+  pthread_mutex_lock(&L->mutex);
+  if (L->react == 0) {
+    if (L->alive == LUA_HEALTHCHECK_MAGIC) {
+      res = 0;
+      L->alive = 0;
+    } else {
+      res = -1;
+    }
+  } else {
+    /* thread didn't respond to the previous heartbeat */
+    res = -1;
+  }
+  pthread_mutex_unlock(&L->mutex);
+  return res;
+}
+#endif
+
--- a/src/lstate.h	2025-07-15 14:44:32.482563916 +0200
+++ b/src/lstate.h	2025-07-15 14:44:01.988917551 +0200
@@ -13,6 +13,11 @@
 #include "ltm.h"
 #include "lzio.h"
 
+#ifdef LUA_HEALTHCHECK_EVAL
+#include <stdatomic.h>
+#include <pthread.h>
+#endif
+
 
 /*
 
@@ -199,9 +204,18 @@
   unsigned short nCcalls;  /* number of nested C calls */
   l_signalT hookmask;
   lu_byte allowhook;
+
+#ifdef LUA_HEALTHCHECK_EVAL
+  atomic_bool react;
+  pthread_mutex_t mutex;
+  int alive;
+#endif
 };
 
 
+#define LUA_HEALTHCHECK_MAGIC 33443311
+
+
 #define G(L)	(L->l_G)
 
 
--- a/src/luaconf.h	2025-07-15 14:44:32.482563916 +0200
+++ b/src/luaconf.h	2025-07-15 14:44:01.988917551 +0200
@@ -46,6 +46,15 @@
 
 
 /*
+@@ LUA_HEALTHCHECK_EVAL enables main loop healthchecking.
+** Define it if you want Lua to healthcheck the main eval loop
+** and enable hang detection via
+** lua_getheartbeatresponse/lua_sendheartbeatrequest API.
+*/
+/* #define LUA_HEALTHCHECK_EVAL */
+
+
+/*
 ** By default, Lua on Windows use (some) specific Windows features
 */
 #if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)
--- a/src/lua.h	2025-07-15 14:44:32.482563916 +0200
+++ b/src/lua.h	2025-07-15 14:44:01.988917551 +0200
@@ -312,6 +312,16 @@
 
 
 /*
+** heartbeat functions
+*/
+
+#ifdef LUA_HEALTHCHECK_EVAL
+LUA_API int lua_getheartbeatresponse (lua_State *L);
+LUA_API int lua_sendheartbeatrequest (lua_State *L);
+#endif
+
+
+/*
 ** miscellaneous functions
 */
 
--- a/src/lvm.c	2025-07-15 14:44:32.482563916 +0200
+++ b/src/lvm.c	2025-07-15 14:44:01.987917497 +0200
@@ -782,6 +782,15 @@
     Protect(luaV_finishset(L,t,k,v,slot)); }
 
 
+#ifdef LUA_HEALTHCHECK_EVAL
+static void luaV_respondtoheartbeat (lua_State *L) {
+  pthread_mutex_lock(&L->mutex);
+  L->alive = LUA_HEALTHCHECK_MAGIC;
+  L->react = 0;
+  pthread_mutex_unlock(&L->mutex);
+}
+#endif
+
 
 void luaV_execute (lua_State *L) {
   CallInfo *ci = L->ci;
@@ -798,6 +807,11 @@
   for (;;) {
     Instruction i;
     StkId ra;
+#ifdef LUA_HEALTHCHECK_EVAL
+    if (L->react) {
+      luaV_respondtoheartbeat(L);
+    }
+#endif
     vmfetch();
     vmdispatch (GET_OPCODE(i)) {
       vmcase(OP_MOVE) {
