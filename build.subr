#!/usr/bin/env bash
#
# Shell script for building Phoenix-RTOS ports
#
# Common functions
#
# Copyright 2024 Phoenix Systems
# Author: Daniel Sawka
#
# SPDX-License-Identifier: BSD-3-Clause
#

# Variables needed for the functions below
: "${PREFIX_PORT:?variable unset}"
: "${PREFIX_PORT_BUILD:?variable unset}"
: "${PORTS_MIRROR_BASEURL:?variable unset}"

# b_port_download(baseurl, filename, [orig_filename])
#  Fetch a file from ${baseurl}${filename} (or ${baseurl}${orig_filename} if provided) and save as ${filename}
#  in current port's directory. Provide ${orig_filename} if filename on the external server doesn't follow the
#  package-X.Y.Z.ext convention (e.g. it's a hash). If download fails, try again from ${PORTS_MIRROR_BASEURL}${filename}.
#
#  This function also verifies file integrity if checksums/${filename}.sha256 file exists (opt-in feature).
b_port_download() {
  local baseurl="${1:?baseurl missing}"
  local filename="${2:?filename missing}"
  local orig_filename="${3:-$filename}"

  local checksum_file="${PREFIX_PORT}/checksums/${filename}.sha256"

  if [ ! -f "${PREFIX_PORT}/${filename}" ]; then
    if ! wget "${baseurl}${orig_filename}" -O "${PREFIX_PORT}/${filename}.part" --no-check-certificate; then
      wget "${PORTS_MIRROR_BASEURL}${filename}" -O "${PREFIX_PORT}/${filename}.part" --no-check-certificate
    fi

    if [ -f "${checksum_file}" ]; then
      read -r line <"${checksum_file}" || true
      local expected_checksum="${line%% *}"

      if [ -z "${expected_checksum}" ]; then
        b_die "No checksum found in ${checksum_file}"
      fi

      local actual_checksum="$(shasum -b -a 256 "${PREFIX_PORT}/${filename}.part")"
      actual_checksum="${actual_checksum%% *}"

      if [ "${expected_checksum}" = "${actual_checksum}" ]; then
        echo "Checksum OK for \"${filename}\""
      else
        b_die "Checksum INVALID for \"${filename}\": expected \"${expected_checksum}\", got \"${actual_checksum}\""
      fi
    fi

    mv -f "${PREFIX_PORT}/${filename}.part" "${PREFIX_PORT}/${filename}"
  fi
}

# b_port_apply_patches(srcdir, [patch_subdir])
#  Apply patches to files in ${srcdir}. Non-recursive - use multiple calls with
#  ${patch_subdir} if you group patches into separate directories.
b_port_apply_patches() {
  local srcdir="${1:?srcdir missing}"
  local patch_subdir="${2:-.}"

  local patch_dir="${PREFIX_PORT}/patches/${patch_subdir}"
  local marker_dir="${PREFIX_PORT_BUILD}/_markers/${patch_subdir}"
  if [ -d "${patch_dir}" ]; then
    mkdir -p "${marker_dir}"
  fi

  # Restores the initial value of nullglob option upon function return
  trap "$(shopt -p nullglob)" RETURN
  shopt -s nullglob

  for patchfile in "${patch_dir}"/*.patch; do
    if [ ! -f "${marker_dir}/$(basename "${patchfile}").applied" ]; then
      echo "applying patch: ${patchfile}"
      patch -d "${srcdir}" -p1 <"${patchfile}"
      touch "${marker_dir}/$(basename "${patchfile}").applied"
    fi
  done
}


b_install_host() {
	local filelist=("${@:1}")
	local absdir="${PREFIX_BUILD}/host-prog/"
	mkdir -p "$absdir"

	for file in "${filelist[@]}"; do
		if ! [ -f "$file" ]; then
			echo -e "\033[0;31mFile $file does not exist \033[0m"
			exit 1
		fi

    echo -e "\033[0;35mInstalling $(basename "$file") into host-prog\033[0m"
		install -m 755 "$file" "$absdir"
	done
}

export -f b_port_download b_port_apply_patches b_install_host
